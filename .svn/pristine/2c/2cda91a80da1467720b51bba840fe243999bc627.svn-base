function [tfrontline,thresh_out] = front_line(temp_zl,thresh_in,grd,flen_crit,logic_morph)
% front_line - extract frontal line and dumping frontline to the struct variable 
%
% Usage: [tfrontline,thresh_out] = front_line(temp_zl,thresh_in,grd,flen_crit,logic_morph)
%
% Input:
%   temp_zl - temperature variable
%   thresh_in - threshold input
%   grd - grid info
%   flen_crit - length criterion for detecting front
%   logic_morph - switch of morphology processing
%
% Output:
%   tfrontline - frontal line detect result (struct array)
%   thresh_out - threshold output
%% =========================================================
[txgrad,tygrad] = grad_sobel(temp_zl,grd.pm,grd.pn,grd.mask_rho);
tgrad = sqrt(txgrad .^ 2 + tygrad .^ 2);
% tangle is across-front direction
tangle = atan2d(tygrad,txgrad);
disp('edge localization...')
[bw, thresh_out] = edge_localization(temp_zl,tgrad,tangle,thresh_in);
%necessary morphological processing to detect frontal line
%remove isolated frontal pixels
bw = bwmorph(bw,'clean'); 
% remove H-connect pixels
bw = bwmorph(bw,'hbreak');
%Make sure that edges are thinned or nearly thinned  
bw2 = bwmorph(bw,'thin', Inf);
% %% test edgelink module
% gapsize = 25;
% bw2 = filledgegaps(bw2, gapsize);
%%
[M,bw_new] = edge_extract(bw2,tgrad,grd,tangle);
%% post-processing 
%提取长度大于flen_crit的锋面
bw_flen=zeros(size(temp_zl));
fnum = 0;
for ifr=1:ff
    r=M{ifr}.row;
    c=M{ifr}.col;
    flen = M{ifr}.flen;
    if flen > flen_crit
        fnum = fnum +1 ;
        tfrontline{fnum}=M{ifr};
        for ip = 1:length(r)
            bw_flen(r(ip),c(ip))=1;
        end
    end
end
if logic_morph
    % deal with morphology operator to connect neighbor segment
    %bw2=bwmorph(bw1,'close',Inf);  % close操作会将非锋面点改为锋面点，在后续操作会报错，考虑将形态学变换放在后面   
end
%
if fnum==0
    tfrontline=[];
    disp('no detected frontline')
end
%
