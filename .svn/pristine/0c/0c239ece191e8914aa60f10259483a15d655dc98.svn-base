function [info_area,tfrontarea] = front_area(tfrontline,temp_zl,grd,thresh)
% front_area: detect frontal zone based on frontal line at last step
% Input:
%   tfrontline - struct type, frontal line detected at last step
%   temp_zl - temperature variable for diagnose
%   grd -  grid info (struct type array)
%   thresh - threshold we use, [lowThresh,highThresh]
% Ouput:
%   tfrontarea: frontal zone detect result (struct array)
lon = grd.lon_rho;
lat = grd.lat_rho;
lowThresh = thresh(1);
highThresh = thresh(2);
[txgrad,tygrad] = grad_sobel(temp_zl,grd.pm,grd.pn,grd.mask_rho);
tgrad = sqrt(txgrad .^ 2 + tygrad .^ 2);
%注意此方向为梯度方向（横锋方向); tangle+90°为垂直梯度方向（沿锋方向）
tangle = atan2d(tygrad,txgrad);
[sector] = sector_dividing8(tangle);
fronta = zeros(size(tgrad));
fronta(tgrad > highThresh) = 1;
%--preprocessing for fronta
% fronta = bwmorph(fronta,'close',Inf);
% fronta = bwmorph(fronta,'clean');
fnum = length(tfrontline);
for ifr =1:fnum
    row = tfrontline{ifr}.row;
    col = tfrontline{ifr}.col;
    pnum = length(row);
    for  ip = 1:pnum
        %frontline as the central line to extract front zone
        pcenter_row = row(ip);
        pcenter_col = col(ip);
        pcenter_sector = sector(pcenter_row,pcenter_col);
        pcenter_tangle = tangle(pcenter_row,pcenter_col);
        [r0,c0] = find_sector_neighbor8(pcenter_sector,pcenter_row,pcenter_col,'across');
        width = zeros(2,1);
        % 记录锋区边缘点和横锋方向锋区点
        for ii=1:2
            % 初始化
            brdy_row(ii) = pcenter_row;
            brdy_col(ii) = pcenter_col;
            frow = [pcenter_row];
            fcol = [pcenter_col];
            start_prow = pcenter_row;
            start_pcol = pcenter_col;
            prow = r0(ii);
            pcol = c0(ii);
            if fronta(prow,pcol) ~= 1
                BB{ii}.row = frow;
                BB{ii}.col = fcol;
                continue
            else
                width(ii)= spheric_dist(lat(start_prow,start_pcol), ...
                    lat(prow,pcol), lon(start_prow,start_pcol), lon(prow,pcol));
                frow = [frow prow];
                fcol = [fcol pcol];
            end
            % 循环寻找边界点
            for m=1:length(row)*2
                psector= sector(prow,pcol);
                [rr,cc]=find_sector_neighbor8(psector,prow,pcol,'across');
                for j=1:2
                    L1(j)=neighbor8_decide(rr(j),cc(j),start_prow,start_pcol);
                    L3(j)=(rr(j)==start_prow) & (cc(j)==start_pcol);
                    %找到不与起始点相邻的锋面像素点
                    L(j)= (~L1(j)) & (~L3(j));
                end
                next_prow=rr(find(L==1));
                next_pcol=cc(find(L==1));
                if fronta(next_prow,next_pcol)==1 & isnan(tgrad(next_prow,next_pcol))~=1
                    width(ii)= width(ii) + spheric_dist(lat(next_prow,next_pcol), ...
                        lat(prow,pcol), lon(next_prow,next_pcol),lon(prow,pcol));
                    frow = [frow next_prow];
                    fcol = [fcol next_pcol];
                else
                    brdy_row(ii)=prow;
                    brdy_col(ii)=pcol;
                    break
                end
                %更新迭代
                start_prow=prow;
                start_pcol=pcol;
                prow=next_prow;
                pcol=next_pcol;
            end
            BB{ii}.row = frow;
            BB{ii}.col = fcol;
        end
        row_right = fliplr(BB{2}.row(2:end));
        row_left = BB{1}.row;
        col_right = fliplr(BB{2}.col(2:end));
        col_left = BB{1}.col;
        across_row =  [row_left row_right];
        across_col = [col_left col_right];
        across_fronta{ip}.brow_left = BB{1}.row(end);
        across_fronta{ip}.bcol_left = BB{1}.col(end);
        across_fronta{ip}.brow_right = BB{2}.row(end);
        across_fronta{ip}.bcol_right = BB{2}.col(end);
        across_fronta{ip}.row = across_row;
        across_fronta{ip}.col =  across_col;
        for j = 1:length(across_row)
            across_fronta{ip}.lon(j) = grd.lon_rho(across_row(j),across_col(j));
            across_fronta{ip}.lat(j) = grd.lat_rho(across_row(j),across_col(j));
            across_fronta{ip}.tgrad(j) = tgrad(across_row(j),across_col(j));
            across_fronta{ip}.sector(j) = sector(across_row(j),across_col(j));
        end
        across_fronta{ip}.width = width(1) + width(2);
    end
    for ip = 1:pnum
        brow_left(ip) = across_fronta{ip}.brow_left;
        bcol_left(ip)= across_fronta{ip}.bcol_left;
        brow_right(ip) = across_fronta{ip}.brow_right;
        bcol_right(ip) = across_fronta{ip}.bcol_right;
        across_fronta_width(ip) =  across_fronta{ip}.width;
        left_lon(ip) = lon(brow_left(ip),bcol_left(ip));
        left_lat(ip) = lat(brow_left(ip),bcol_left(ip));
        right_lon(ip) = lon(brow_right(ip),bcol_right(ip));
        right_lat(ip) = lat(brow_right(ip),bcol_right(ip));
    end
    % calculate max-width and mean width of frontal zone
    max_width(ifr) = max(across_fronta_width);
    mean_width(ifr) = mean(across_fronta_width);
    % calculate area of frontal zone
    poly_row = [brow_left fliplr(brow_right)];
    poly_col = [bcol_left fliplr(bcol_right)];
    % use internal function "polyarea" for now, maybe have bugs!
    area = polyarea(poly_row,poly_col)*(0.03*111e3)^2;  % unit: m^2
    % equivalent mean frontal width = frontal area/frontal length, unit: m
    equivalent_width(ifr) = area / tfrontline{ifr}.flen;
    % storage struct array of frontarea info
    info_area{ifr}.max_width = max(across_fronta_width);
    info_area{ifr}.mean_width = mean(across_fronta_width);
    info_area{ifr}.area = area;
    info_area{ifr}.equivalent_width = area / tfrontline{ifr}.flen;
    info_area{ifr}.across_fronta_width = across_fronta_width;
    info_area{ifr}.brow_left = brow_left;
    info_area{ifr}.brow_right = brow_right;
    info_area{ifr}.bcol_left = bcol_left;
    info_area{ifr}.bcol_right = bcol_right;
    info_area{ifr}.left_lon = left_lon;
    info_area{ifr}.left_lat = left_lat;
    info_area{ifr}.right_lon = right_lon;
    info_area{ifr}.right_lat = right_lat;
    % storage frontarea array
    tfrontarea{ifr} = across_fronta;
    clear BB across_fronta
    clear brow_left brow_right  bcol_left bcol_right poly_row poly_col 
    clear area  across_fronta_width equivalent_width
    clear right_lat right_lon left_lat left_lon
end
end