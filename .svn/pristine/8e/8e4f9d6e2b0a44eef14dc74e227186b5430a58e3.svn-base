function [tfrontline,thresh] = front_line(temp_zl,dtcrit,grd,flen_crit,logic_morph)
% extract frontal line from variable 'temp_zl' and dumping front line
% parameter to the struct variable 'tfrontline'
%
% Input:
%
[txgrad,tygrad] = grad_sobel(temp_zl,grd.pm,grd.pn,grd.mask_rho);
tgrad = sqrt(txgrad .^ 2 + tygrad .^ 2);
%注意此方向为梯度方向（横锋方向）；tangle+90°为垂直梯度方向（沿锋方向）
tangle = atan2d(tygrad,txgrad);
%
disp('Canny edge detection...')
[bw,thresh] = fn_edge(temp_zl,'canny_new',txgrad,tygrad,tgrad,tangle,[dtcrit]);
bw2=bwmorph(bw,'clean');
bw2=bwmorph(bw2,'hbreak');
%处理遇到节点（相邻点大于等于3个）锋面走向
%统计锋面参数（排序、记录长度和强度）
%根据边缘检测的结果，从每个锋面的端点开始找
bw2=bwmorph(bw2,'close',Inf);
bw2=bwmorph(bw2,'thin',Inf);
[segment,num]=bwlabel(bw2,8); % extract and identify different  front lines
[sector]=sector_dividing(tangle);
ff=0;
for ifr=1:num
    [row, col] = find(segment == ifr);
    bw_ifr = bwselect(bw2, col, row, 8);
    bw_sector=bw_ifr.*sector;
    bw_tangle=bw_ifr.*tangle;
    [N,neigh_num]=find_neighbor_info(bw2,row,col);
    neigh1=find(neigh_num==1);  %找出只有1个邻域的端点
    for i1=1:length(neigh1)
        pstart_row=row(neigh1(i1));
        pstart_col=col(neigh1(i1));
        if bw_ifr(pstart_row,pstart_col)~=0
            bw_ifr(pstart_row,pstart_col)=0;
            ip=neigh1(i1);
            porder=[ip];  % 设置边缘点顺序
            next_point_row=N{ip}.row;
            next_point_col=N{ip}.col;
            for m=1:length(row)*2
                if isempty(next_point_row)==0 && isempty(next_point_col)==0
                    prow=next_point_row;
                    pcol=next_point_col;
                    [ip]=find(row(:)==next_point_row & col(:)==next_point_col);
                    if neigh_num(ip)==1
                        porder=[porder ip];
                        bw_ifr(prow,pcol)=0;
                        next_point_row=[];
                        next_point_col=[];
                        ff=ff+1; % 锋面判别终止，数量更新
                        break
                    elseif neigh_num(ip)==2
                        porder=[porder ip];
                        bw_ifr(prow,pcol)=0;
                        rr=N{ip}.row;
                        cc=N{ip}.col;
                        for j=1:2
                            L(j)=(rr(j)==pstart_row) & (cc(j)==pstart_col);
                        end
                        LL=find(L~=1);
                        next_point_row=rr(LL);
                        next_point_col=cc(LL);
                        pstart_row = prow;
                        pstart_col = pcol;
                        continue  % 继续寻找下一个相邻锋面像素
                    elseif neigh_num(ip) >=3
                        p_sector= bw_sector(prow,pcol);
                        bw_ifr(prow,pcol)=0;
                        [rr,cc]=find_sector_neighbor(p_sector,prow,pcol,'along');
                        %如像素点8邻域两端均有锋面像素点，确定其连线为锋面
                        if bw_sector(rr(1),cc(1))~=0 && bw_sector(rr(2),cc(2))~=0
                            if (pstart_row== rr(1) && pstart_col == cc(1))
                                next_point_row = rr(2);
                                next_point_col = cc(2);
                                porder=[porder ip];
                            elseif (pstart_row== rr(2) && pstart_col == cc(2))
                                next_point_row = rr(1);
                                next_point_col = cc(1);
                                porder=[porder ip];
                            else
                                ff=ff+1; % 锋面判别终止，数量更新
                                break
                            end
                            pstart_row = prow;
                            pstart_col = pcol;
                        else  %相邻3点均不位于梯度方向，只有两种情况，而且只能有3个相邻点
                            for j=1:2
                                L1(j)=neighbor8_decide(rr(j),cc(j),pstart_row,pstart_col);
                                L2(j)=(bw_ifr(rr(j),cc(j))==1);
                                L3(j)=(rr(j)==pstart_row) & (cc(j)==pstart_col);
                                %找到不与起始点相邻的锋面像素点
                                L(j)= (~L1(j)) & (L2(j)) & (~L3(j));
                            end
                            Lnum=length(find(L==1));
                            if Lnum==0 || Lnum==2
                                %如在沿梯度方向没找到锋面像素点
                                bw_ifr(prow,pcol)=0;
                                porder=[porder ip];
                                ff=ff+1; % 锋面判别终止，数量更新
                                break
                            elseif Lnum==1
                                next_point_row=rr(find(L==1));
                                next_point_col=cc(find(L==1));
                                bw_ifr(prow,pcol)=0;
                                porder=[porder ip];
                                pstart_row = prow;
                                pstart_col = pcol;
                                continue
                            end
                        end
                    end                  
                end
            end
            M{ff}.order=porder;
            M{ff}.row=row(porder);
            M{ff}.col=col(porder);
        end
    end
    clear N
end
% 统计锋面信息
bw_new=zeros(size(temp_zl));
for ifr=1:ff
    r=M{ifr}.row;
    c=M{ifr}.col;
    for ip=1:length(r)
        M{ifr}.lon(ip)=grd.lon_rho(r(ip),c(ip));
        M{ifr}.lat(ip)=grd.lat_rho(r(ip),c(ip));
        M{ifr}.tgrad(ip)=tgrad(r(ip),c(ip));
        M{ifr}.tangle(ip)=tangle(r(ip),c(ip));
        bw_new(r(ip),c(ip))=1;
    end
    flen=0;
    for ip = 1:length(r)-1
        flen = flen + spheric_dist(grd.lat_rho(r(ip),c(ip)), ...
            grd.lat_rho(r(ip+1),c(ip+1)), grd.lon_rho(r(ip),c(ip)), ...
            grd.lon_rho(r(ip+1),c(ip+1)));
    end
    M{ifr}.flen=flen;
    M{ifr}.mean_tgrad=nanmean(M{ifr}.tgrad);
end
%提取长度大于flen_crit的锋面
bw_flen=zeros(size(temp_zl));
fnum = 0;
for ifr=1:ff
    r=M{ifr}.row;
    c=M{ifr}.col;
    flen = M{ifr}.flen;
    if flen > flen_crit
        fnum = fnum +1 ;
        tfrontline{fnum}=M{ifr};
        for ip = 1:length(r)
            bw_flen(r(ip),c(ip))=1;
        end
    end
end
%
if fnum==0
    tfrontline=[];
end
%
