function [info_area,tfrontarea] = front_area(tfrontline,bw,temp_zl,grd,thresh)
% front_area: detect frontal zone based on frontal line rendered from
%   function 'front_line'
% Input:
%   tfrontline - struct type, frontal line detected at last step
%   temp_zl - temperature variable for diagnose
%   grd -  grid info (struct type array)
%   thresh - threshold we use, [lowThresh,highThresh]
% Ouput:
%   tfrontarea: frontal zone detect result (struct array)
lon = grd.lon_rho;
lat = grd.lat_rho;
lowThresh = thresh(1);
highThresh = thresh(2);
[tgrad, tangle] = get_front_variable(temp_zl,grd);
%dealing with tgrad and tangle of linkage pixels
[rowL,colL] = find(bw==1 & (tgrad < highThresh | isnan(tgrad)));
[sector] = sector_dividing8(tangle);
fronta = zeros(size(tgrad));
fronta(tgrad > highThresh) = 1;
%--preprocessing for fronta
% fronta = bwmorph(fronta,'close',Inf);
% fronta = bwmorph(fronta,'clean');
fnum = length(tfrontline);
for ifr =1:fnum
    row = tfrontline{ifr}.row;
    col = tfrontline{ifr}.col;
    for  ip = 1: length(row)
        %detect frontal zone from central line 
        pcenter_row = row(ip);
        pcenter_col = col(ip);
        pcenter_sector = sector(pcenter_row,pcenter_col);
%         pcenter_tangle = tangle(pcenter_row,pcenter_col);
        [r0,c0] = find_sector_neighbor8(pcenter_sector,pcenter_row,pcenter_col,'across');
        % temp along the front direction
%         temp_zl(r0(1),c0(1))
%         temp_zl(r0(2),c0(2))
%         temp_zl(pcenter_row,pcenter_col)
         tgrad(pcenter_row,pcenter_col)
        width = zeros(2,1);
        % 记录锋区边缘点和横锋方向锋区点
        
        for ii=1:2
            % 初始化
            brdy_row(ii) = pcenter_row;
            brdy_col(ii) = pcenter_col;
            frow = [pcenter_row];
            fcol = [pcenter_col];
            start_prow = pcenter_row;
            start_pcol = pcenter_col;
            prow = r0(ii);
            pcol = c0(ii);
            if fronta(prow,pcol) ~= 1
                front_brdy{ii}.row = frow;
                front_brdy{ii}.col = fcol;
                continue
            else
                width(ii) = spheric_dist(lat(start_prow,start_pcol), ...
                    lat(prow,pcol), lon(start_prow,start_pcol), lon(prow,pcol));
                frow = [frow prow];
                fcol = [fcol pcol];
            end
            % 循环寻找边界点
            for m=1:length(row)*2
                psector = sector(prow,pcol);
                [rr,cc] = find_sector_neighbor8(psector,prow,pcol,'across');
                next_prow = rr(ii);
                next_pcol = cc(ii);
%                 for j=1:2
%                     L1(j)=neighbor8_decide(rr(j),cc(j),start_prow,start_pcol);
%                     L3(j)=(rr(j)==start_prow) & (cc(j)==start_pcol);
%                     %找到不与起始点相邻的锋面像素点
%                     L(j)= (~L1(j)) & (~L3(j));
%                 end
%                 next_prow=rr(find(L==1));
%                 next_pcol=cc(find(L==1));
                if fronta(next_prow,next_pcol)==1 % & isnan(tgrad(next_prow,next_pcol))~=1
                    width(ii)= width(ii) + spheric_dist(lat(next_prow,next_pcol), ...
                        lat(prow,pcol), lon(next_prow,next_pcol),lon(prow,pcol));
                    frow = [frow next_prow];
                    fcol = [fcol next_pcol];
                else
                    brdy_row(ii)=prow;
                    brdy_col(ii)=pcol;
                    break
                end
                %更新迭代
                start_prow=prow;
                start_pcol=pcol;
                prow=next_prow;
                pcol=next_pcol;
            end
            front_brdy{ii}.row = frow;
            front_brdy{ii}.col = fcol;
        end
        
        row_right = fliplr(front_brdy{2}.row(2:end));
        row_left = front_brdy{1}.row;
        col_right = fliplr(front_brdy{2}.col(2:end));
        col_left = front_brdy{1}.col;
        across_row =  [row_left row_right];
        across_col = [col_left col_right];
        across_fronta{ip}.brow_left = front_brdy{1}.row(end);
        across_fronta{ip}.bcol_left = front_brdy{1}.col(end);
        across_fronta{ip}.brow_right = front_brdy{2}.row(end);
        across_fronta{ip}.bcol_right = front_brdy{2}.col(end);
        across_fronta{ip}.row = across_row;
        across_fronta{ip}.col =  across_col;
        for j = 1:length(across_row)
            across_fronta{ip}.lon(j) = grd.lon_rho(across_row(j),across_col(j));
            across_fronta{ip}.lat(j) = grd.lat_rho(across_row(j),across_col(j));
            across_fronta{ip}.tgrad(j) = tgrad(across_row(j),across_col(j));
            across_fronta{ip}.sector(j) = sector(across_row(j),across_col(j));
        end
        across_fronta{ip}.width = width(1) + width(2);
    end
    for ip = 1:length(row)
        brow_left(ip) = across_fronta{ip}.brow_left;
        bcol_left(ip)= across_fronta{ip}.bcol_left;
        brow_right(ip) = across_fronta{ip}.brow_right;
        bcol_right(ip) = across_fronta{ip}.bcol_right;
        across_fronta_width(ip) =  across_fronta{ip}.width;
        left_lon(ip) = lon(brow_left(ip),bcol_left(ip));
        left_lat(ip) = lat(brow_left(ip),bcol_left(ip));
        right_lon(ip) = lon(brow_right(ip),bcol_right(ip));
        right_lat(ip) = lat(brow_right(ip),bcol_right(ip));
    end
    % calculate max-width and mean width of frontal zone
    max_width(ifr) = max(across_fronta_width);
    mean_width(ifr) = mean(across_fronta_width);
    % calculate area of frontal zone
    poly_row = [brow_left fliplr(brow_right)];
    poly_col = [bcol_left fliplr(bcol_right)];
    % use internal function "polyarea" for now, maybe have bugs!
    area = polyarea(poly_row,poly_col)*(0.03*111e3)^2;  % unit: m^2
    % equivalent mean frontal width = frontal area/frontal length, unit: m
    equivalent_width(ifr) = area / tfrontline{ifr}.flen;
    % storage struct array of frontarea info
    info_area{ifr}.max_width = max(across_fronta_width);
    info_area{ifr}.mean_width = mean(across_fronta_width);
    info_area{ifr}.area = area;
    info_area{ifr}.equivalent_width = area / tfrontline{ifr}.flen;
    info_area{ifr}.across_fronta_width = across_fronta_width;
    info_area{ifr}.brow_left = brow_left;
    info_area{ifr}.brow_right = brow_right;
    info_area{ifr}.bcol_left = bcol_left;
    info_area{ifr}.bcol_right = bcol_right;
    info_area{ifr}.left_lon = left_lon;
    info_area{ifr}.left_lat = left_lat;
    info_area{ifr}.right_lon = right_lon;
    info_area{ifr}.right_lat = right_lat;
    % storage frontarea array
    tfrontarea{ifr} = across_fronta;
    clear BB across_fronta
    clear brow_left brow_right  bcol_left bcol_right poly_row poly_col 
    clear area  across_fronta_width equivalent_width
    clear right_lat right_lon left_lat left_lon
    clear row col
end
end