function [tfrontline,bw_final,thresh_out] = front_line(temp_zl,thresh_in,grd,flen_crit,logic_morph)
% front_line - main function of extracting frontal line from SST and dumping frontline to the struct variable
%    
% Usage: [tfrontline,thresh_out] = front_line(temp_zl,thresh_in,grd,flen_crit,logic_morph)
%
% Input:
%   temp_zl - 2D temperature variable after preprocessing
%   thresh_in - threshold input (C/km)
%   grd - struct variable of grid info
%   flen_crit - length criterion for detecting front (unit: m)
%   logic_morph - switch of morphology processing (0 or 1)
%
% Output:
%   tfrontline - struct variable of frontal line detect result 
%   thresh_out - threshold output (C/km)
%   bw_final - final binary image
%%
%set test figure output switch
[tgrad, tangle] = get_front_variable(temp_zl,grd);
% [sector8] = sector_dividing8(tangle);
%% edge localization
disp('edge localization...')
[bw, thresh_out] = edge_localization(temp_zl,tgrad,tangle,thresh_in);
%% edge follow
disp('edge following...')
[M,bw_new] = edge_follow(bw,tgrad,grd,tangle);
%% edge merge
disp('edge merging...')
gapsize = 3;
[M_merge,bw_merge] = edge_merge(tgrad,grd,tangle,bw_new,M,gapsize);
%% calculate frontal line parameter
[tgrad_mean,flen] = cal_front_parameter(M_merge,grd,tgrad);
%% post_processing
[tfrontline,bw_final] = edge_postprocessing(M_merge,bw_merge,grd,tgrad_mean,flen,flen_crit,logic_morph);
%%
if fnum==0
    tfrontline=[];
    disp('no detected frontline')
end
end %end main function

%% calculate parameter of frontal line: mean frontal strength and front length
% other parameter to be finished
function [tgrad_mean,flen] = cal_front_parameter(M,grd,tgrad)
    lon = grd.lon_rho;
    lat = grd.lat_rho;
    fnum = length(M);
    tgrad_mean = zeros(fnum,1);
    flen = zeros(fnum,1);
    for ifr = 1:fnum
        row = M{ifr}.row;
        col = M{ifr}.col;
        flen(ifr) = 0;
        tgrad_sum = tgrad(row(1),col(1));
        tgrad_num = 1;
        for ip = 2:length(row)
            flen(ifr) = flen(ifr) + spheric_dist(lat(row(ip-1),col(ip-1)),lat(row(ip),col(ip)), ...
                lon(row(ip-1),col(ip-1)),lon(row(ip),col(ip)));
            if isnan(tgrad(row(ip),col(ip))) ~=1
                tgrad_sum = tgrad_sum + tgrad(row(ip),col(ip));
                tgrad_num = tgrad_num + 1;
            end
        end
        tgrad_mean(ifr) = tgrad_sum/tgrad_num;
        clear tgrad_sum row col
    end
end

%% postprocessing
function [M_final,bw_final] = edge_postprocessing(M_merge,bw_merge,grd,tgrad_mean,flen,flen_crit,logic_morph,min_length_pixel)
%去除长度（像素点）小于min_length_pixel
if nargin<8
    min_length_pixel = 3;
end
bw_flen=zeros(size(bw_merge));
bw_final=zeros(size(bw_merge));
fnum = 0;
for ifr=1:length(M_merge)
    row=M_merge{ifr}.row;
    col=M_merge{ifr}.col;
    if length(row) >= min_length_pixel && flen(ifr) > flen_crit
        fnum = fnum +1;
        M_merge{ifr}.flen = flen(ifr);
        M_merge{ifr}.tgrad_mean = tgrad_mean(ifr);
        M_final{fnum}=M_merge{ifr};
        for ip = 1:length(row)
            bw_flen(row(ip),col(ip))=1;
        end       
    end
end
if logic_morph
    % deal with morphology operator to connect neighbor segment
    %bw2=bwmorph(bw1,'close',Inf);  
    % close操作会将非锋面点改为锋面点，在后续操作会报错， 
end
bw_final = bw_flen;
end