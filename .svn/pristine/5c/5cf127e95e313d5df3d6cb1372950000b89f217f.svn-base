function [M_merge,bw_merge] = edge_merge(tgrad,grd,tangle,bw,M,gapsize,min_len)
% main function: final step of frontline detection, merge neighboring edge segments.
% Input:      
%   bw : binary image derived from edge_localization
%   tgrad :  gradient magnitude  
%   grd : struct variable of grid info
%   tangle : gradient direction  (0-360 degree)
%   M : struct variable of frontal line output after function edge_follow 
%   gapsize: blob for link edge segment (in pixel)
%   min_len: length threhold for edge merge
%
% Ouput:      
%   M_merge : struct variable of frontal line output after edge merging
%   bw_merge : binary image after edge merging
%
% See also:  edge_localization, edge_follow, front_line
%   
% Description:
%     
% ==============================================
if nargin<7
    min_len = gapsize;
end
bw = bwmorph(bw,'clean');  % remove isolated pixel
% initialize bw and M
M_merge=[];
bw_merge = bw;  
blob = circularstruct(gapsize); % build blob for edge link
blob_size = 2*gapsize + 1;
% Get coordinates of endpoints
[rj, cj, re, ce] = findendsjunctions(bw);
for ip = 1:length(re)
    r0 = re(ip);
    c0 = ce(ip);
    if isnan(r0) || isnan(c0)
        continue
    end
    ff = locate_front(M,r0,c0);
    %find another endpoint in this edge
    rr = [M{ff}.row(1),M{ff}.row(end)];
    cc = [M{ff}.col(1),M{ff}.col(end)];
    ind = find( ~(r0 == rr & c0 == cc) );
    r1 = rr(ind);
    c1 = cc(ind);
    % return global index from local bw
    [bw_loc0,blob_loc,row_g,col_g] = index_local_to_global(bw,r0,c0,gapsize);
    bw_loc = blob_loc & bw_loc0;
    %find all frontal line pixels within blob extent
    [rLoc , cLoc] = find(bw_loc == 1);
    for iLoc = 1:length(rLoc)
        bw_row_g(iLoc) = row_g(rLoc(iLoc),cLoc(iLoc));
        bw_col_g(iLoc) = col_g(rLoc(iLoc),cLoc(iLoc));
        if find((bw_row_g(iLoc) == re & bw_col_g(iLoc) == ce))
            idxBwG(iLoc) = 1;
        else
            idxBwG(iLoc) = 0;
        end
        % remove endpoint of tracked frontline, remaining other front's endpoint
        if find((bw_row_g(iLoc) == r0 & bw_col_g(iLoc) == c0) | ...
                (bw_row_g(iLoc) == r1 & bw_col_g(iLoc) == c1)) 
            idxBwG(iLoc) = 0;
        end
    end
    % endpoint number in the blob extent
    idxBw = find(idxBwG==1);
    if length(idxBw) ~= 0 
        row_ep = bw_row_g(idxBw);
        col_ep = bw_col_g(idxBw);
        [ep_row,ep_col,min_value] = find_least_direction_change(r0,c0,row_ep,col_ep,tangle);
        if isempty(ep_row) || isempty(ep_col)
            continue
        else
            % find index from re&ce array
            ip0 = find(re(:) == ep_row & ce(:) == ep_col);
            %  set both of connected endpoints NaN to skip later loop
            re(ip) = NaN; ce(ip) = NaN;
            re(ip0)  = NaN; ce(ip0) = NaN;
            % locate front number by endpoint row and col
            % 在这个blob内找到满足条件的endpoint，定位其edge编号
            [ff1] = locate_front(M,ep_row,ep_col);
        end
    else
        continue
    end
%     % 找到圈内所有锋面点，并剔除端点ip及所在锋面的所有点
% 
%     for ii = 1:length(M{ff}.row)
%         rf = M{ff}.row(ii);
%         cf = M{ff}.col(ii);
%         [rtmp,ctmp] = find(row_g == rf & col_g == cf);
%         if isempty(rtmp)
%             continue
%         end
%         idx = find(rtmp == local_bw_row & ctmp == local_bw_col);
%         if ~isempty(idx)
%             local_bw_row(idx) = [];
%             local_bw_col(idx) = [];
%         end
%     end
% %     % find local index front point except endpoints in this edge no. ff
% %     [local_bw_row , local_bw_col] = find(bw_loc == 1 & ...
% %         ~(r_glo_ind == r0 & c_glo_ind == c0) & ...
% %         ~(r_glo_ind == r1 & c_glo_ind == c1 ));
%     if isempty(local_bw_row)
%         continue
%     end
%     % 找出blob内，所有其他锋面的endpoint
%     num = 0 ;
%     for i = 1:length(local_bw_row)
%         re_glo = row_g(local_bw_row(i), 1);
%         ce_glo = col_g(1,local_bw_col(i));
%         % find endpoint index 
%         ep_ind = find(re(:)  == re_glo & ce(:) == ce_glo);
%         if ~isempty(ep_ind)
%             num = num +1;
%             ep_row(num) = re(ep_ind);
%             ep_col(num) = ce(ep_ind);
%             angle_diff(num) = abs(tangle(ep_row(num),ep_col(num))-tangle(r0,c0));
%         end
%     end  
%     if num ~= 0  % endpoint exist in the blob
%     mk = find(abs(angle_diff) > 180);
%     angle_diff(mk) = 360 - angle_diff(mk);
%     [min_value , min_ind] = nanmin(angle_diff);
    clear angle_diff ep_row ep_col
    %在整个图中只显示这两个锋面，然后用之前的filledge函数，把两条锋面连起来
    bw_before_link = zeros(size(bw));
    for j = 1:length(M{ff}.row)
        bw_merge(M{ff}.row(j),M{ff}.col(j)) = 0;
        bw_before_link(M{ff}.row(j),M{ff}.col(j)) = 1;
    end
    clear j
    for j = 1:length(M{ff1}.row)
        bw_merge(M{ff1}.row(j),M{ff1}.col(j)) = 0;
        bw_before_link(M{ff1}.row(j),M{ff1}.col(j)) = 1;
    end
    clear j
    % link two edges
    bw_after_link = filledgegaps(bw_before_link, gapsize);
    % identify linking points between two edges
    [rowT,colT] = find(bw_before_link == 0 & bw_after_link == 1);
    for ii = 1:length(rowT)
        %人为改变这几个点的锋面阈值和锋面方向
        tgrad(rowT(ii),colT(ii))  = tgrad(r0,c0);
        tangle(rowT(ii),colT(ii))  = tangle(r0,c0);
    end
    % examine if exist branch structure
    [rj1, cj1, ~, ~] = findendsjunctions(bw_after_link);
    if isempty(rj1) == 1 || isempty(cj1) == 1
        bw_single_new = bw_after_link;
    else
        % 测试数据不包含这个，后面待测试
        % 根据edge长度判断 branch的锋面走向，cut off shorter branch and remain the longer one
        [bw_single_new] = extract_single_segment(bw_after_link);
    end
    %再返回整个的bw图中
    bw_merge(bw_single_new == 1) = 1;
    % 增加对于处理后的tgrad和tangle 的处理，方便诊断锋区
end  % end for loop ip 

bw_merge = bwmorph(bw_merge,'thin');
[rj, cj, re, ce] = findendsjunctions(bw_merge);
% 更新M
% 调用edge_follow得到M，更改edge_follow
[M_merge,bw_merge] = edge_follow(bw_merge,tgrad,grd,tangle);

end  % end main function

function [bw_loc,blob_loc,row_g,col_g] = index_local_to_global(bw_g,r0,c0,gapsize)
% dealing with blob in boundary and return global bw index for blob 
%  
% Input:      
%   bw_g : global binary image derived 
%   r0,c0 : row and column index of endpoint
%   gapsize: same as main function
%
% Ouput:      
%   bw_loc : local bw in the blob
%   blob_loc: blob extent after boundary modify
%   row_g, col_g : global row and col index
% ==============================================
[rows, cols] = size(bw_g);
blob_size = 2*gapsize + 1;
% deal with boundary
rr = [max(1,(r0-gapsize)) : min(rows , (r0+gapsize))];
cc = [max(1,(c0-gapsize)) : min(cols , (c0+gapsize))];
bw_loc = bw_g(rr,cc);
blob_loc = circularstruct(gapsize); 
row_g = zeros(blob_size);
col_g = zeros(blob_size);
% set global row & col index for blob
for i = 1:gapsize
    row_g(gapsize+1-i , :) = r0 - i ;
    row_g(gapsize+1+i , :) = r0 +i;
    row_g(gapsize+1 , :) = r0;
    col_g(: , gapsize+1-i) = c0 - i ;
    col_g(: , gapsize+1+i) = c0 +i;
    col_g(: , gapsize+1) = c0;
end
nan_row = row_g(:,1) < 1 | row_g(:,1) > rows;
nan_col = col_g(1,:) < 1 | col_g(1,:) > cols;
row_g(:,nan_col) = []; row_g(nan_row,:) = [];
col_g(:,nan_col) = []; col_g(nan_row,:) = [];
blob_loc(:,nan_col) = []; blob_loc(nan_row,:) = [];
end % end function

function [front_index] = locate_front(M,ep_row,ep_col)
% locate front index according endpoint 
%
% Input:      
%   bw : binary image derived from edge_localization
%   tgrad :  gradient magnitude  
%   grd : struct variable of grid info
%   tangle : gradient direction  (0-360 degree)
%   M : struct variable of frontal line output after function edge_follow 
%   gapsize: blob for link edge segment (in pixel)
%   min_len: length threhold for edge merge
%
% Ouput:      
%   M_merge : struct variable of frontal line output after edge merging
%   bw_merge : binary image after edge merging
% ==============================================
for ff = 1:length(M)
    r0 = M{ff}.row(1);
    r1 = M{ff}.row(end);
    c0 = M{ff}.col(1);
    c1 = M{ff}.col(end);
    ep_ind = (ep_row == r0 & ep_col == c0) | (ep_row == r1 & ep_col == c1);
    if ep_ind
        front_index = ff;
        return
    else
        front_index = [];
    end
end 

end % end function
