function [tfrontline] = front_line(temp_zl,dtcrit,tgrad,tangle,grd,flen_crit,Ct_crit,logic_frontal_length,logic_morph)
%
disp('Canny edge detection...')
%choose filter method
filter_method='fn_edge';
if strcmp(filter_method,'fn_edge')
    [bw,thresh] = fn_edge(temp_zl,'canny',grd.pm,grd.pn,[dtcrit],'temp',dtcrit); 
elseif strcmp(filter_method,'internal_edge')
     [bw,thresh] = edge(temp_zl,'canny') ;
end
%首先提取长度大于阈值flen_crit的中心线 
if logic_frontal_length==1
    bw10=zeros(size(bw));  %新定义一个边缘检测数组bw10
    for m = 1:500
        [row,col] = find(bw,1); 
        if isempty(row)
            break
        end
        Ct = contour_following(bw);
        bw(Ct(:,1),Ct(:,2)) = 0;
        if size(Ct,1) > Ct_crit
            flen = 0;
            sum_tgrad=tgrad(Ct(1,1),Ct(1,2));
            for n = 1:size(Ct,1)-1
                flen = flen + spheric_dist(grd.lat_rho(Ct(n,1),Ct(n,2)), ...
                    grd.lat_rho(Ct(n+1,1),Ct(n+1,2)), grd.lon_rho(Ct(n,1),Ct(n,2)), ...
                    grd.lon_rho(Ct(n+1,1),Ct(n+1,2)));
                sum_tgrad=sum_tgrad+tgrad(Ct(n,1),Ct(n,2));
            end
            mean_tgrad=sum_tgrad/size(Ct,1);
            if flen>flen_crit  && mean_tgrad>dtcrit*1.0
            for n = 1:size(Ct,1)
                bw10(Ct(n,1),Ct(n,2))=1;
            end               
            end
        end
    end
    bw=bw10;
end
% bw5=bwmorph(bw,'bridge');
%对bw进行多次平滑滤波，再给定阈值将平滑后的结果二值化
if logic_morph==1
%图像闭操作和细化操作
bw4=bwmorph(bw,'close',Inf);
bw4=bwmorph(bw4,'thin',Inf);
%
bw=bw4;
end

%最终提取并输出符合条件的锋面中心线
fnum = 0;
for m = 1:500
    [row,col] = find(bw,1); 
    if isempty(row)
        break
    end
    Ct = contour_following(bw);
    bw(Ct(:,1),Ct(:,2)) = 0;
    if size(Ct,1) > Ct_crit
        flen = 0;
        sum_tgrad=tgrad(Ct(1,1),Ct(1,2));
        for n = 1:size(Ct,1)-1
            flen = flen + spheric_dist(grd.lat_rho(Ct(n,1),Ct(n,2)), ...
                grd.lat_rho(Ct(n+1,1),Ct(n+1,2)), grd.lon_rho(Ct(n,1),Ct(n,2)), ...
                grd.lon_rho(Ct(n+1,1),Ct(n+1,2)));
            sum_tgrad=sum_tgrad+tgrad(Ct(n,1),Ct(n,2));
        end
        mean_tgrad=sum_tgrad/size(Ct,1);
%         if flen>flen_crit  && mean_tgrad>dtcrit*1.0
        fnum = fnum + 1; 
        for n = 1:size(Ct,1)
            eval(['tfrontline.f',num2str(fnum),'(n,1) = grd.lon_rho(Ct(n,1),Ct(n,2));']);
            eval(['tfrontline.f',num2str(fnum),'(n,2) = grd.lat_rho(Ct(n,1),Ct(n,2));']);
            eval(['tfrontline.f',num2str(fnum),'(n,3) = tgrad(Ct(n,1),Ct(n,2));']);
            eval(['tfrontline.f',num2str(fnum),'(n,4) = tangle(Ct(n,1),Ct(n,2));']);
        end               
        tfrontline.mtgrad(fnum)=mean_tgrad;
        tfrontline.flen(fnum)= flen;
%         end
    end
    
 tfrontline.fnum = fnum;    
   
end
if fnum==0
tfrontline=[];
end
end