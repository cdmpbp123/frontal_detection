function [M,bw_new] = edge_follow(bw,tgrad,grd,tangle)
%
% edge_follow :  this function extract frontal line from binary map derived from edge_localization function.
%
% Usage:  [M,bw_new] = edge_follow(bw,tgrad,grd,tangle)
%
% Input:      
%   bw : binary image derived from edge_localization
%   tgrad :  gradient magnitude  
%   grd : struct variable of grid info
%   tangle : gradient direction  (0-360 degree)
%
% Ouput:      
%   M : struct variable of frontal line output  
%   bw_new : binary image after edge_follow
%
% See also:  edge_localization, edge_merge, front_line
%   
% Description:
%     The algorithm scan the edge map from finding endpoint which has only one neighbor edge pixel, 
%     then examine the 8-connected neighbors when meet branch pixels. When a branch
%     point is encountered, the algorithm follows the branch that least
%     changes the direction of the current contour. The remaining
%     branch is then processed as a separate contour. 
% ==============================================
tgrad = tgrad .* bw; %make sure tgrad and tangle have same mask with preprocessed bw
tangle = tangle .* bw;
[segment,num] = bwlabel(bw,8);
[sector]  = sector_dividing8(tangle);
bw_new=zeros(size(tgrad));
lon = grd.lon_rho;
lat = grd.lat_rho;
ff = 0 ;
for ifr = 1 : num
    [row, col] = find(segment == ifr);
    bw_ifr = bwselect(bw, col, row, 8);
    %
    bw_ifr1 = bwmorph(bw_ifr,'thin');
    %
    bw_index = bw_ifr;
    bw_sector = bw_ifr.*sector;
    bw_tangle = bw_ifr.*tangle;
    [N,neigh_num] = find_neighbor_info(bw,row,col);
    % find endpoint index
    neigh1 = find(neigh_num  ==  1);
    for i1 = 1 : length(neigh1)
        ip = neigh1(i1);
        start_prow = row(ip);
        start_pcol = col(ip);
        if bw_index(start_prow,start_pcol) == 0 || bw_new(start_prow,start_pcol) == 2
            continue
        end
        % order of frontal pixel 
        porder = ip;
        bw_index(row(ip),col(ip)) = 0;
        bw_new(row(ip),col(ip)) = 1;
        next_prow = N{ip}.row;
        next_pcol = N{ip}.col;
        for m = 1 : length(row)*2
            if length(next_prow) ~= 1 || length(next_pcol) ~= 1
                break
            end
            prow = next_prow;
            pcol = next_pcol;
            [ip] = find(row(:) == next_prow & col(:) == next_pcol);
            if bw_new(row(ip),col(ip)) == 2
                ff = ff +1;
                break
            end
            if neigh_num(ip) == 1
                porder = [porder ip];
                bw_index(row(ip),col(ip)) = 0;
                bw_new(row(ip),col(ip)) = 1;
                next_prow = [];
                next_pcol = [];
                ff = ff+1;
                break
            elseif neigh_num(ip) == 2
                porder = [porder ip];
                bw_index(row(ip),col(ip)) = 0;
                bw_new(row(ip),col(ip)) = 1;
                rr = N{ip}.row;
                cc = N{ip}.col;
                for j = 1:2
                    L(j) = (rr(j) == start_prow) & (cc(j) == start_pcol);
                end
                LL = find(L ~= 1);
                next_prow = rr(LL);
                next_pcol = cc(LL);
                start_prow = prow;
                start_pcol = pcol;
                continue  % jump back to loop: m
            elseif neigh_num(ip) >= 3
                p_sector= bw_sector(prow,pcol);
                [rr,cc]=find_sector_neighbor8(p_sector,prow,pcol,'along');
                if isempty(rr) || isempty(cc)
                    ff = ff+1;
                    break
                end
                %判断三个neighbor点是否落在锋面方向上，落在哪个方向上
                % determine neighbor points fall into which frontal direction 
                for ii = 1:neigh_num(ip)
                    nrow = N{ip}.row(ii);
                    ncol = N{ip}.col(ii);
                    for jj =1:2
                        L(ii,jj) = ((rr(jj) == nrow) & (cc(jj) == ncol));
                    end
                    if L(ii,1) == 1 || L(ii,2) == 1
                        LL(ii) = 1;
                    else
                        LL(ii) = 0;
                    end
                end
                miss_index = find(LL ~=1);
                hit_index = find(LL == 1);
                miss_row = N{ip}.row(miss_index);
                miss_col = N{ip}.col(miss_index);
                hit_row = N{ip}.row(hit_index);
                hit_col = N{ip}.col(hit_index);
                clear L LL
                bw_index(row(ip),col(ip)) = 0;
                bw_new(row(ip),col(ip)) = 1;
                if length(hit_row) == 2  
                    % highest priority: 如像素点p的沿锋方向均为锋面像素点，直接确定其连线为下一点方向，优先级最高
                    start_index = find(hit_row(:) == start_prow & hit_col(:) == start_pcol, 1);
                    next_index = find(~(hit_row(:) == start_prow & hit_col(:) == start_pcol));
                    if isempty(start_index)
                        bw_new(start_prow,start_pcol) = 2;
                        %change along-front pixel bw value
                        bw_new(hit_row(1),hit_col(1)) = 1;
                        bw_new(hit_row(2),hit_col(2)) = 1;
                        porder(end) = [] ;
                        ff = ff+1;
                        break
                    else
                        next_prow = hit_row(next_index);
                        next_pcol = hit_col(next_index);
                        porder = [porder ip];
                    end
                    skip_index = 1; % in this case, only 1 miss row/col, set skip_index = 1
                elseif length(hit_row) == 1 
                    %如像素点p沿锋方向只有1个锋面像素点, 通过像素点方向确定下一点位置
                    if hit_row == start_prow && hit_col == start_pcol  % 像素点P沿锋方向的锋面像素点为锋线的前一点
                        [next_prow,next_pcol,min_change] = find_least_direction_change(prow,pcol,miss_row,miss_col,tangle);
                        porder =  [porder ip];
                        if isempty(next_prow) || isempty(next_pcol)
                            break
                        end
                        skip_index = find(miss_row(:) ~= next_prow | miss_col(:) ~= next_pcol );
                    else
                        next_prow = hit_row;
                        next_pcol = hit_col;
                        porder =  [porder ip];
                        skip_index =  find(miss_row(:) ~= start_prow | miss_col(:) ~= start_pcol);
                    end
                elseif length(hit_row) == 0 %如像素点p沿锋方向没有锋面像素点, 通过像素点方向确定下一点位置
                    start_index = find(miss_row(:) == start_prow & miss_col(:) == start_pcol);
                    miss_row(start_index) = [];
                    miss_col(start_index) = [];
                    [next_prow,next_pcol,min_change] = find_least_direction_change(prow,pcol,miss_row,miss_col,tangle);
                    if isempty(next_prow) || isempty(next_prow)
                        break
                    end
                    porder =  [porder ip];
                    skip_index = find(miss_row(:) ~= next_prow | miss_col(:) ~= next_pcol);
                end
                start_prow = prow;
                start_pcol = pcol;
                r_skip = miss_row(skip_index);
                c_skip = miss_col(skip_index);
                if bw_new(r_skip,c_skip) == 0
                    bw_new(r_skip,c_skip) = 2;
                end
            end
        end
%         M{ff}.order=porder;
        M{ff}.row=row(porder);
        M{ff}.col=col(porder);
        % add other output for figure
        for ip = 1:length(M{ff}.row)
            M{ff}.lon(ip) = lon(M{ff}.row(ip),M{ff}.col(ip));
            M{ff}.lat(ip) = lat(M{ff}.row(ip),M{ff}.col(ip));
            M{ff}.tgrad(ip) = tgrad(M{ff}.row(ip),M{ff}.col(ip));
            M{ff}.tangle(ip) = tangle(M{ff}.row(ip),M{ff}.col(ip));
        end
    end
    clear N
end
% mk_bw2 = find( bw_new ==2 ) ;
bw_new(bw_new == 2) = 0;
% add edge filter
filter_pixel_length = 1;
[bw_filter,M_filter] = edge_filter(bw_new,M,filter_pixel_length);
bw_new = bw_filter;
M = M_filter;
[rj, cj, ~, ~] = findendsjunctions(bw_new);
if isempty(rj) ~= 1 || isempty(cj) ~= 1
    error('error: after edge following, junction points should no longer exist')
end

end % end main function

function [bw_filter,M_filter] = edge_filter(bw,M,filter_pixel_length)
% 
%
fr_num_filter = 1;
bw_filter = zeros(size(bw));
for ifr = 1:length(M)
    if length(M{ifr}.row) > filter_pixel_length
        r=M{ifr}.row;
        c=M{ifr}.col;
        for ip=1:length(r)
            bw_filter(r(ip),c(ip))=1;
        end
        M_filter{fr_num_filter} = M{ifr};
        fr_num_filter = fr_num_filter +1;
    end
end

end  % end function edge_filter
